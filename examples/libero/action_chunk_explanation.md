# action_chunk 详细说明

## action_chunk 的格式

`action_chunk` 是一个**7维动作向量**的数组，每个动作代表末端执行器（end effector）的**增量（delta）变化**，而不是绝对位置。

### 动作维度分解

```python
action = [dx, dy, dz, dax, day, daz, gripper]
         [0,  1,  2,  3,   4,   5,   6     ]
```

| 维度 | 索引 | 名称 | 含义 | 单位 | 说明 |
|------|------|------|------|------|------|
| **位置增量** | 0-2 | `dx, dy, dz` | 末端执行器在世界坐标系中的位置增量 | 米 (m) | 相对于当前位置的移动量 |
| **旋转增量** | 3-5 | `dax, day, daz` | 末端执行器的旋转增量（轴角表示） | 弧度 (rad) | 相对于当前姿态的旋转 |
| **夹爪动作** | 6 | `gripper` | 夹爪的开合状态 | 归一化值 | 通常 -1 表示打开，1 表示闭合 |

## 具体例子

### 例子1：向前移动

```python
action = [0.05, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0]
         # ↑     ↑    ↑    ↑    ↑    ↑    ↑
         # x+5cm y不变 z不变 无旋转 无旋转 无旋转 打开夹爪
```

**含义**：
- 末端执行器在 X 方向（通常是向前）移动 5 厘米
- Y 和 Z 方向不变
- 姿态不变
- 夹爪打开

### 例子2：向上并旋转

```python
action = [0.0, 0.0, 0.03, 0.1, 0.0, 0.0, -1.0]
         # ↑    ↑    ↑     ↑    ↑    ↑    ↑
         # x不变 y不变 z+3cm 绕x轴旋转0.1rad 无其他旋转 打开夹爪
```

**含义**：
- 末端执行器在 Z 方向（向上）移动 3 厘米
- 绕 X 轴旋转约 5.7 度（0.1 弧度）
- 夹爪打开

### 例子3：抓取动作

```python
action = [0.02, 0.01, -0.01, 0.0, 0.0, 0.0, 1.0]
         # ↑     ↑      ↑     ↑    ↑    ↑    ↑
         # x+2cm y+1cm  z-1cm 无旋转 无旋转 无旋转 闭合夹爪
```

**含义**：
- 末端执行器向右前下方移动
- 姿态保持不变
- 夹爪闭合（准备抓取）

## 关键代码证据

### 1. 位置增量（Delta Position）

```python
# 代码第361行：累积计算预测位置
predicted_end_pos = current_eef_pos.copy()
for action in action_chunk[:10]:
    predicted_end_pos = predicted_end_pos + action[:3]  # ← 这里是加法，说明是增量
```

**说明**：如果 `action[:3]` 是绝对位置，应该是赋值而不是加法。

### 2. 旋转增量（Delta Rotation）

```python
# 代码第539行：构建完整动作
fix_action = np.concatenate([
    new_action_vec,           # [0:3] 位置增量
    action_chunk[0][3:6],     # [3:6] 旋转增量（保持policy的旋转）
    [original_gripper]        # [6] 夹爪
])
```

### 3. 夹爪动作

```python
# 代码第534行：获取夹爪动作
original_gripper = action_chunk[0][6]  # 通常是 -1 (打开) 或 1 (闭合)
```

## 动作执行流程

### 步骤1：Policy推理

```python
# Policy基于当前观察，预测未来50步的动作
action_chunk = response["actions"]  # shape: (50, 7)
```

### 步骤2：取前N个动作

```python
# 根据 replan_steps，只取前N个动作执行
action_plan.extend(action_chunk[: args.replan_steps])  # 例如取前5个
```

### 步骤3：执行动作

```python
# 从队列中取出一个动作
action = action_plan.popleft()  # shape: (7,)

# 在模拟器中执行
obs, reward, done, info = env.step(action.tolist())
```

### 步骤4：模拟器处理

模拟器内部会：
1. 读取当前末端执行器位置：`current_eef_pos`
2. 计算新位置：`new_eef_pos = current_eef_pos + action[0:3]`
3. 计算新姿态：`new_eef_quat = current_eef_quat + action[3:6]`（轴角转四元数）
4. 设置夹爪：`gripper = action[6]`

## 为什么使用增量而不是绝对位置？

### 优点

1. **更稳定**：增量动作更容易学习，policy只需要预测"移动多少"，而不是"移动到哪"
2. **更安全**：避免突然的大幅度移动
3. **更灵活**：可以适应不同的初始位置
4. **训练友好**：增量动作的分布更集中，更容易学习

### 缺点

1. **累积误差**：如果每一步都有小误差，会累积成大误差
2. **需要重新规划**：这就是为什么需要 `replan_steps`，定期重新规划来纠正误差

## 实际数值范围

根据代码中的注释和常见实践：

| 维度 | 典型范围 | 说明 |
|------|---------|------|
| `dx, dy, dz` | -0.1 到 0.1 米 | 通常每步移动 1-10 厘米 |
| `dax, day, daz` | -0.5 到 0.5 弧度 | 通常每步旋转 5-30 度 |
| `gripper` | -1.0 到 1.0 | -1=打开，1=闭合，中间值=部分闭合 |

## 可视化示例

假设当前末端执行器位置是 `[0.5, 0.3, 0.2]`（米），执行以下动作序列：

```python
action_chunk = [
    [0.05, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],  # 向前5cm，打开夹爪
    [0.05, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],  # 再向前5cm
    [0.0, 0.0, -0.03, 0.0, 0.0, 0.0, -1.0], # 向下3cm
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],    # 闭合夹爪
    [0.0, 0.0, 0.05, 0.0, 0.0, 0.0, 1.0],   # 向上5cm（抓取物体）
]
```

**执行后的位置变化**：

```
初始位置: [0.50, 0.30, 0.20]
Step 0后: [0.55, 0.30, 0.20]  (+0.05, 0, 0)
Step 1后: [0.60, 0.30, 0.20]  (+0.05, 0, 0)
Step 2后: [0.60, 0.30, 0.17]  (0, 0, -0.03)
Step 3后: [0.60, 0.30, 0.17]  (位置不变，夹爪闭合)
Step 4后: [0.60, 0.30, 0.22]  (0, 0, +0.05)
```

## 与观察空间的关系

观察空间包含：

```python
obs = {
    "robot0_eef_pos": [x, y, z],           # 当前绝对位置
    "robot0_eef_quat": [qx, qy, qz, qw],  # 当前绝对姿态（四元数）
    "robot0_gripper_qpos": [g],            # 当前夹爪位置
    "agentview_image": ...,                # 相机图像
    ...
}
```

**关键区别**：
- **观察**：绝对位置和姿态
- **动作**：相对增量（delta）

## 总结

- `action_chunk` 是 **7维增量动作** 的数组
- 前3维：位置增量（dx, dy, dz），单位是米
- 中间3维：旋转增量（轴角表示），单位是弧度
- 最后1维：夹爪动作，-1=打开，1=闭合
- 每个动作都是**相对于当前状态**的增量，不是绝对位置
- 模拟器会将这些增量应用到当前状态，得到新的状态
